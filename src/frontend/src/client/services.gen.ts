// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type { HealthCheckHealthGetResponse, ReadinessCheckReadinessGetResponse, TestEndpointTestGetResponse, AuthJwtLoginApiAuthLoginPostData, AuthJwtLoginApiAuthLoginPostResponse, AuthJwtLogoutApiAuthLogoutPostResponse, RegisterRegisterApiAuthRegisterPostData, RegisterRegisterApiAuthRegisterPostResponse, AuthGetCurrentUserApiAuthMeGetResponse, AuthRefreshTokenApiAuthTokenRefreshPostData, AuthRefreshTokenApiAuthTokenRefreshPostResponse, GetVideosApiVideosGetResponse, GetSubtitlesApiVideosSubtitlesSubtitlePathGetData, GetSubtitlesApiVideosSubtitlesSubtitlePathGetResponse, StreamVideoApiVideosSeriesEpisodeGetData, StreamVideoApiVideosSeriesEpisodeGetResponse, UploadSubtitleApiVideosSubtitleUploadPostData, UploadSubtitleApiVideosSubtitleUploadPostResponse, ScanVideosApiVideosScanPostResponse, GetUserVideosApiVideosUserGetResponse, GetVideoVocabularyApiVideosVideoIdVocabularyGetData, GetVideoVocabularyApiVideosVideoIdVocabularyGetResponse, GetVideoStatusApiVideosVideoIdStatusGetData, GetVideoStatusApiVideosVideoIdStatusGetResponse, UploadVideoGenericApiVideosUploadPostData, UploadVideoGenericApiVideosUploadPostResponse, UploadVideoToSeriesApiVideosUploadSeriesPostData, UploadVideoToSeriesApiVideosUploadSeriesPostResponse, TranscribeVideoApiProcessTranscribePostData, TranscribeVideoApiProcessTranscribePostResponse, FilterSubtitlesApiProcessFilterSubtitlesPostData, FilterSubtitlesApiProcessFilterSubtitlesPostResponse, ApplySelectiveTranslationsApiProcessApplySelectiveTranslationsPostData, ApplySelectiveTranslationsApiProcessApplySelectiveTranslationsPostResponse, ProcessChunkApiProcessChunkPostData, ProcessChunkApiProcessChunkPostResponse, FullPipelineApiProcessFullPipelinePostData, FullPipelineApiProcessFullPipelinePostResponse, GetTaskProgressApiProcessProgressTaskIdGetData, GetTaskProgressApiProcessProgressTaskIdGetResponse, GetWordInfoApiVocabularyWordInfoWordGetData, GetWordInfoApiVocabularyWordInfoWordGetResponse, MarkWordKnownApiVocabularyMarkKnownPostData, MarkWordKnownApiVocabularyMarkKnownPostResponse, MarkWordKnownByLemmaApiVocabularyMarkKnownLemmaPostData, MarkWordKnownByLemmaApiVocabularyMarkKnownLemmaPostResponse, GetVocabularyStatsApiVocabularyStatsGetData, GetVocabularyStatsApiVocabularyStatsGetResponse, GetVocabularyLibraryApiVocabularyLibraryGetData, GetVocabularyLibraryApiVocabularyLibraryGetResponse, GetVocabularyLevelApiVocabularyLibraryLevelGetData, GetVocabularyLevelApiVocabularyLibraryLevelGetResponse, SearchVocabularyApiVocabularySearchPostData, SearchVocabularyApiVocabularySearchPostResponse, BulkMarkLevelApiVocabularyLibraryBulkMarkPostData, BulkMarkLevelApiVocabularyLibraryBulkMarkPostResponse, GetSupportedLanguagesApiVocabularyLanguagesGetResponse, GetTestDataApiVocabularyTestDataGetResponse, GetBlockingWordsApiVocabularyBlockingWordsGetData, GetBlockingWordsApiVocabularyBlockingWordsGetResponse, CreateVocabularyApiVocabularyPostData, CreateVocabularyApiVocabularyPostResponse, AddCustomWordApiVocabularyCustomAddPostData, AddCustomWordApiVocabularyCustomAddPostResponse, DeleteCustomWordApiVocabularyCustomWordIdDeleteData, DeleteCustomWordApiVocabularyCustomWordIdDeleteResponse, ProfileGetApiProfileGetResponse, ProfileGetSupportedLanguagesApiProfileLanguagesGetResponse, ProfileUpdateLanguagesApiProfileLanguagesPutData, ProfileUpdateLanguagesApiProfileLanguagesPutResponse, ProfileGetSettingsApiProfileSettingsGetResponse, ProfileUpdateSettingsApiProfileSettingsPutData, ProfileUpdateSettingsApiProfileSettingsPutResponse, ProgressGetUserApiProgressUserGetResponse, ProgressUpdateUserApiProgressUpdatePostData, ProgressUpdateUserApiProgressUpdatePostResponse, ProgressGetDailyApiProgressDailyGetData, ProgressGetDailyApiProgressDailyGetResponse, GameStartSessionApiGameStartPostData, GameStartSessionApiGameStartPostResponse, GameGetSessionApiGameSessionSessionIdGetData, GameGetSessionApiGameSessionSessionIdGetResponse, GameSubmitAnswerApiGameAnswerPostData, GameSubmitAnswerApiGameAnswerPostResponse, GameGetUserSessionsApiGameSessionsGetData, GameGetUserSessionsApiGameSessionsGetResponse, ParseSrtContentApiSrtParsePostData, ParseSrtContentApiSrtParsePostResponse, ParseSrtFileApiSrtParseFilePostData, ParseSrtFileApiSrtParseFilePostResponse, ConvertToSrtApiSrtConvertToSrtPostData, ConvertToSrtApiSrtConvertToSrtPostResponse, ValidateSrtContentApiSrtValidateGetData, ValidateSrtContentApiSrtValidateGetResponse, LogFrontendEntryApiDebugFrontendLogsPostData, LogFrontendEntryApiDebugFrontendLogsPostResponse, DebugHealthApiDebugHealthGetResponse, CleanupTestDataApiTestCleanupDeleteResponse } from './types.gen';

/**
 * Health Check
 * Health check endpoint
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const healthCheckHealthGet = (): CancelablePromise<HealthCheckHealthGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/health'
}); };

/**
 * Readiness Check
 * Readiness check endpoint - verifies that all services are initialized
 *
 * Returns 200 when ready, 503 when still initializing
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const readinessCheckReadinessGet = (): CancelablePromise<ReadinessCheckReadinessGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/readiness'
}); };

/**
 * Test Endpoint
 * Simple test endpoint
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const testEndpointTestGet = (): CancelablePromise<TestEndpointTestGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/test'
}); };

/**
 * Auth:Jwt.Login
 * @param data The data for the request.
 * @param data.formData
 * @returns BearerResponse Successful Response
 * @throws ApiError
 */
export const authJwtLoginApiAuthLoginPost = (data: AuthJwtLoginApiAuthLoginPostData): CancelablePromise<AuthJwtLoginApiAuthLoginPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/auth/login',
    formData: data.formData,
    mediaType: 'application/x-www-form-urlencoded',
    errors: {
        400: 'Bad Request',
        422: 'Validation Error'
    }
}); };

/**
 * Auth:Jwt.Logout
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const authJwtLogoutApiAuthLogoutPost = (): CancelablePromise<AuthJwtLogoutApiAuthLogoutPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/auth/logout',
    errors: {
        401: 'Missing token or inactive user.'
    }
}); };

/**
 * Register:Register
 * @param data The data for the request.
 * @param data.requestBody
 * @returns UserRead Successful Response
 * @throws ApiError
 */
export const registerRegisterApiAuthRegisterPost = (data: RegisterRegisterApiAuthRegisterPostData): CancelablePromise<RegisterRegisterApiAuthRegisterPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/auth/register',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        400: 'Bad Request',
        422: 'Validation Error'
    }
}); };

/**
 * Auth Get Current User
 * Get current authenticated user information.
 *
 * This endpoint returns the profile information for the currently authenticated user.
 * Requires a valid JWT access token in the Authorization header.
 *
 * **Authentication Required**: Yes
 *
 * Returns:
 * UserResponse: User profile information including:
 * - id: Unique user identifier (UUID)
 * - username: User's username
 * - email: User's email address
 * - is_superuser: Whether user has admin privileges
 * - is_active: Whether user account is active
 * - created_at: Account creation timestamp (ISO format)
 * - last_login: Last login timestamp (ISO format, nullable)
 *
 * Raises:
 * HTTPException: 401 Unauthorized if token is invalid or missing
 *
 * Example:
 * ```bash
 * curl -H "Authorization: Bearer <token>" http://localhost:8000/api/auth/me
 * ```
 *
 * Response:
 * ```json
 * {
 * "id": "123e4567-e89b-12d3-a456-426614174000",
 * "username": "johndoe",
 * "email": "john@example.com",
 * "is_superuser": false,
 * "is_active": true,
 * "created_at": "2025-10-03T10:00:00",
 * "last_login": "2025-10-03T11:30:00"
 * }
 * ```
 * @returns UserResponse Successful Response
 * @throws ApiError
 */
export const authGetCurrentUserApiAuthMeGet = (): CancelablePromise<AuthGetCurrentUserApiAuthMeGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/auth/me'
}); };

/**
 * Auth Refresh Token
 * Refresh access token with automatic token rotation
 *
 * This endpoint exchanges a valid refresh token for:
 * 1. A new access token (for API calls)
 * 2. A new refresh token (rotated from old one)
 *
 * Token Rotation Security:
 * - Each refresh token can only be used once
 * - If an old token is reused, it indicates theft and all tokens are revoked
 * - Rotation creates a "family" of tokens that are tracked together
 *
 * The refresh token should be stored in an HTTP-only cookie for security.
 *
 * Returns:
 * TokenRefreshResponse: New access token and rotated refresh token
 *
 * Raises:
 * HTTPException: 401 if refresh token is invalid, expired, or reused (theft detected)
 *
 * Security Note:
 * If you receive a 401 error mentioning "token reuse", all tokens have been
 * revoked for security. The user must login again.
 * @param data The data for the request.
 * @param data.refreshToken
 * @returns TokenRefreshResponse Successful Response
 * @throws ApiError
 */
export const authRefreshTokenApiAuthTokenRefreshPost = (data: AuthRefreshTokenApiAuthTokenRefreshPostData = {}): CancelablePromise<AuthRefreshTokenApiAuthTokenRefreshPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/auth/token/refresh',
    cookies: {
        refresh_token: data.refreshToken
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Get Videos
 * Retrieve list of all available videos and series for the current user.
 *
 * Scans the configured videos directory and returns metadata for all accessible
 * video files, including subtitle availability and episode information.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * current_user (User): Authenticated user
 * video_service (VideoService): Video service dependency
 *
 * Returns:
 * list[VideoInfo]: List of video metadata objects containing:
 * - series: Series/show name
 * - season: Season number
 * - episode: Episode number
 * - title: Episode title
 * - path: Relative file path
 * - has_subtitles: Whether subtitles exist
 * - duration: Video duration in seconds
 *
 * Raises:
 * HTTPException: 500 if directory scanning fails
 *
 * Example:
 * ```bash
 * curl -X GET "http://localhost:8000/api/videos"           -H "Authorization: Bearer <token>"
 * ```
 *
 * Response:
 * ```json
 * [
 * {
 * "series": "Learn German",
 * "season": "1",
 * "episode": "01",
 * "title": "Introduction",
 * "path": "Learn German/S01E01.mp4",
 * "has_subtitles": true,
 * "duration": 1200
 * }
 * ]
 * ```
 * @returns VideoInfo Successful Response
 * @throws ApiError
 */
export const getVideosApiVideosGet = (): CancelablePromise<GetVideosApiVideosGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/videos'
}); };

/**
 * Get Subtitles
 * Serve subtitle files (SRT format) for video playback.
 *
 * Returns subtitle file content as plain text with UTF-8 encoding.
 * Validates file existence and applies security checks to prevent path traversal.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * subtitle_path (str): Relative path to subtitle file
 * current_user (User): Authenticated user
 * video_service (VideoService): Video service dependency
 *
 * Returns:
 * FileResponse: SRT file content with UTF-8 encoding
 *
 * Raises:
 * HTTPException: 404 if subtitle file not found or invalid
 * HTTPException: 500 if file serving fails
 *
 * Example:
 * ```bash
 * curl -X GET "http://localhost:8000/api/videos/subtitles/Learn German/S01E01.srt"           -H "Authorization: Bearer <token>"
 * ```
 *
 * Response: (plain text SRT content)
 * ```
 * 1
 * 00:00:00,000 --> 00:00:05,000
 * Hallo und willkommen!
 *
 * 2
 * 00:00:05,500 --> 00:00:10,000
 * Heute lernen wir Deutsch.
 * ```
 * @param data The data for the request.
 * @param data.subtitlePath
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getSubtitlesApiVideosSubtitlesSubtitlePathGet = (data: GetSubtitlesApiVideosSubtitlesSubtitlePathGetData): CancelablePromise<GetSubtitlesApiVideosSubtitlesSubtitlePathGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/videos/subtitles/{subtitle_path}',
    path: {
        subtitle_path: data.subtitlePath
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Stream Video
 * Stream video file - Requires authentication
 * @param data The data for the request.
 * @param data.series
 * @param data.episode
 * @param data.token Authentication token
 * @param data.authorization Bearer access token
 * @returns unknown Full video content
 * @returns unknown Partial video content (range request)
 * @throws ApiError
 */
export const streamVideoApiVideosSeriesEpisodeGet = (data: StreamVideoApiVideosSeriesEpisodeGetData): CancelablePromise<StreamVideoApiVideosSeriesEpisodeGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/videos/{series}/{episode}',
    path: {
        series: data.series,
        episode: data.episode
    },
    headers: {
        authorization: data.authorization
    },
    query: {
        token: data.token
    },
    errors: {
        401: 'Invalid or missing authentication token',
        404: 'Video file not accessible',
        422: 'Validation Error',
        500: 'Error streaming video'
    }
}); };

/**
 * Upload Subtitle
 * Upload subtitle file for a video - Requires authentication
 * Uses FileSecurityValidator for secure file handling
 * @param data The data for the request.
 * @param data.videoPath
 * @param data.formData
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const uploadSubtitleApiVideosSubtitleUploadPost = (data: UploadSubtitleApiVideosSubtitleUploadPostData): CancelablePromise<UploadSubtitleApiVideosSubtitleUploadPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/videos/subtitle/upload',
    query: {
        video_path: data.videoPath
    },
    formData: data.formData,
    mediaType: 'multipart/form-data',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Scan Videos
 * Scan videos directory for new videos - Requires authentication
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const scanVideosApiVideosScanPost = (): CancelablePromise<ScanVideosApiVideosScanPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/videos/scan'
}); };

/**
 * Get User Videos
 * Get videos for the current user (alias for get_available_videos)
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getUserVideosApiVideosUserGet = (): CancelablePromise<GetUserVideosApiVideosUserGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/videos/user'
}); };

/**
 * Get Video Vocabulary
 * Get vocabulary words extracted from a video
 * @param data The data for the request.
 * @param data.videoId
 * @returns VocabularyWord Successful Response
 * @throws ApiError
 */
export const getVideoVocabularyApiVideosVideoIdVocabularyGet = (data: GetVideoVocabularyApiVideosVideoIdVocabularyGetData): CancelablePromise<GetVideoVocabularyApiVideosVideoIdVocabularyGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/videos/{video_id}/vocabulary',
    path: {
        video_id: data.videoId
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Get Video Status
 * Get processing status for a video
 * @param data The data for the request.
 * @param data.videoId
 * @returns ProcessingStatus Successful Response
 * @throws ApiError
 */
export const getVideoStatusApiVideosVideoIdStatusGet = (data: GetVideoStatusApiVideosVideoIdStatusGetData): CancelablePromise<GetVideoStatusApiVideosVideoIdStatusGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/videos/{video_id}/status',
    path: {
        video_id: data.videoId
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Upload Video Generic
 * Upload a new video file (generic endpoint) - Requires authentication
 * @param data The data for the request.
 * @param data.formData
 * @param data.series
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const uploadVideoGenericApiVideosUploadPost = (data: UploadVideoGenericApiVideosUploadPostData): CancelablePromise<UploadVideoGenericApiVideosUploadPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/videos/upload',
    query: {
        series: data.series
    },
    formData: data.formData,
    mediaType: 'multipart/form-data',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Upload Video To Series
 * Upload a new video file to a series - Requires authentication
 * Uses FileSecurityValidator for secure file handling with path traversal prevention
 * @param data The data for the request.
 * @param data.series
 * @param data.formData
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const uploadVideoToSeriesApiVideosUploadSeriesPost = (data: UploadVideoToSeriesApiVideosUploadSeriesPostData): CancelablePromise<UploadVideoToSeriesApiVideosUploadSeriesPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/videos/upload/{series}',
    path: {
        series: data.series
    },
    formData: data.formData,
    mediaType: 'multipart/form-data',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Transcribe Video
 * Transcribe video audio to generate SRT subtitles using speech recognition.
 *
 * Initiates background transcription task using Whisper or configured transcription
 * service. Validates video file format and existence before starting processing.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * request (TranscribeRequest): Transcription request with:
 * - video_path (str): Relative or absolute path to video file
 * background_tasks (BackgroundTasks): FastAPI background task manager
 * current_user (User): Authenticated user
 * task_progress (dict): Task progress tracking registry
 *
 * Returns:
 * dict: Task initiation response with:
 * - task_id: Unique task identifier for progress tracking
 * - status: "started"
 *
 * Raises:
 * HTTPException: 404 if video file not found
 * HTTPException: 422 if transcription service unavailable or invalid video format
 * HTTPException: 500 if task initialization fails
 *
 * Example:
 * ```bash
 * curl -X POST "http://localhost:8000/api/processing/transcribe"           -H "Authorization: Bearer <token>"           -H "Content-Type: application/json"           -d '{
 * "video_path": "Learn German/S01E01.mp4"
 * }'
 * ```
 *
 * Response:
 * ```json
 * {
 * "task_id": "transcribe_123_1234567890.123",
 * "status": "started"
 * }
 * ```
 *
 * Note:
 * Use the returned task_id with /api/processing/progress/{task_id} to monitor
 * transcription progress. Completed transcription generates an SRT file with
 * the same name as the video file.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const transcribeVideoApiProcessTranscribePost = (data: TranscribeVideoApiProcessTranscribePostData): CancelablePromise<TranscribeVideoApiProcessTranscribePostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/process/transcribe',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Filter Subtitles
 * Filter subtitle content based on user's vocabulary knowledge level.
 *
 * Initiates background processing to filter subtitles, highlighting unknown words
 * and applying vocabulary-based filtering according to user's CEFR level and
 * known word list. Generates filtered subtitle file for adaptive learning.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * request (FilterRequest): Filtering configuration with:
 * - video_path (str): Relative or absolute path to video file
 * background_tasks (BackgroundTasks): FastAPI background task manager
 * current_user (User): Authenticated user
 * task_progress (dict): Task progress tracking registry
 * subtitle_processor (DirectSubtitleProcessor): Subtitle processing service
 *
 * Returns:
 * dict: Task initiation response with:
 * - task_id: Unique task identifier for progress tracking
 * - status: "started"
 *
 * Raises:
 * HTTPException: 422 if subtitle file not found
 * HTTPException: 500 if task initialization fails
 *
 * Example:
 * ```bash
 * curl -X POST "http://localhost:8000/api/processing/filter-subtitles"           -H "Authorization: Bearer <token>"           -H "Content-Type: application/json"           -d '{
 * "video_path": "Learn German/S01E01.mp4"
 * }'
 * ```
 *
 * Response:
 * ```json
 * {
 * "task_id": "filter_123_1234567890.123",
 * "status": "started"
 * }
 * ```
 *
 * Note:
 * Use the returned task_id with /api/processing/progress/{task_id} to monitor
 * filtering progress. Completed filtering generates a filtered SRT file with
 * vocabulary annotations.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const filterSubtitlesApiProcessFilterSubtitlesPost = (data: FilterSubtitlesApiProcessFilterSubtitlesPostData): CancelablePromise<FilterSubtitlesApiProcessFilterSubtitlesPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/process/filter-subtitles',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Apply Selective Translations
 * Apply selective translations based on known words.
 * Re-filters subtitles to show only unknown words that need translation.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const applySelectiveTranslationsApiProcessApplySelectiveTranslationsPost = (data: ApplySelectiveTranslationsApiProcessApplySelectiveTranslationsPostData): CancelablePromise<ApplySelectiveTranslationsApiProcessApplySelectiveTranslationsPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/process/apply-selective-translations',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Process Chunk
 * Process a specific time-based chunk of video for vocabulary extraction and learning.
 *
 * Extracts vocabulary from a defined time segment of a video, performing transcription,
 * translation, and vocabulary analysis on the specified chunk. Useful for focused
 * learning on specific video segments.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * request (ChunkProcessingRequest): Chunk specification with:
 * - video_path (str): Relative or absolute path to video file
 * - start_time (float): Chunk start time in seconds (>= 0)
 * - end_time (float): Chunk end time in seconds (> start_time)
 * background_tasks (BackgroundTasks): FastAPI background task manager
 * current_user (User): Authenticated user
 * task_progress (dict): Task progress tracking registry
 *
 * Returns:
 * dict: Task initiation response with:
 * - task_id: Unique task identifier for progress tracking
 * - status: "started"
 *
 * Raises:
 * HTTPException: 400 if chunk timing is invalid
 * HTTPException: 404 if video file not found
 * HTTPException: 500 if task initialization fails
 *
 * Example:
 * ```bash
 * curl -X POST "http://localhost:8000/api/processing/chunk"           -H "Authorization: Bearer <token>"           -H "Content-Type: application/json"           -d '{
 * "video_path": "Learn German/S01E01.mp4",
 * "start_time": 120.0,
 * "end_time": 180.0
 * }'
 * ```
 *
 * Response:
 * ```json
 * {
 * "task_id": "chunk_123_120_180_1234567890.123",
 * "status": "started"
 * }
 * ```
 *
 * Note:
 * Use the returned task_id with /api/processing/progress/{task_id} to monitor
 * chunk processing. Completed processing returns extracted vocabulary and
 * generates chunk-specific subtitle segments.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const processChunkApiProcessChunkPost = (data: ProcessChunkApiProcessChunkPostData): CancelablePromise<ProcessChunkApiProcessChunkPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/process/chunk',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Full Pipeline
 * Run a full processing pipeline: Transcribe -> Filter -> Translate
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const fullPipelineApiProcessFullPipelinePost = (data: FullPipelineApiProcessFullPipelinePostData): CancelablePromise<FullPipelineApiProcessFullPipelinePostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/process/full-pipeline',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Get Task Progress
 * Monitor progress of a background processing task.
 *
 * Polls the status of an active background task (transcription, filtering, translation,
 * or full pipeline). Returns current progress percentage, status, and step information.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * task_id (str): Unique task identifier from task initiation response
 * current_user (User): Authenticated user
 * task_progress (dict): Task progress tracking registry
 *
 * Returns:
 * ProcessingStatus: Progress information with:
 * - status: "processing", "completed", "error", or "cancelled"
 * - progress: Percentage complete (0-100)
 * - current_step: Description of current processing step
 * - message: Detailed status message
 * - vocabulary (optional): Extracted vocabulary (if applicable)
 * - subtitle_path (optional): Generated subtitle path (if completed)
 * - translation_path (optional): Translation file path (if applicable)
 *
 * Raises:
 * None (returns completed status for missing tasks)
 *
 * Example:
 * ```bash
 * curl -X GET "http://localhost:8000/api/processing/progress/transcribe_123_1234567890.123"           -H "Authorization: Bearer <token>"
 * ```
 *
 * Response (in progress):
 * ```json
 * {
 * "status": "processing",
 * "progress": 45.0,
 * "current_step": "Transcribing audio segments",
 * "message": "Processing segment 45 of 100"
 * }
 * ```
 *
 * Response (completed):
 * ```json
 * {
 * "status": "completed",
 * "progress": 100.0,
 * "current_step": "Processing complete",
 * "message": "Video transcribed successfully",
 * "subtitle_path": "Learn German/S01E01.srt"
 * }
 * ```
 *
 * Note:
 * Frontend should poll this endpoint periodically (e.g., every 2 seconds)
 * until status becomes "completed" or "error". Missing tasks return
 * completed status to prevent infinite polling.
 * @param data The data for the request.
 * @param data.taskId
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getTaskProgressApiProcessProgressTaskIdGet = (data: GetTaskProgressApiProcessProgressTaskIdGetData): CancelablePromise<GetTaskProgressApiProcessProgressTaskIdGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/process/progress/{task_id}',
    path: {
        task_id: data.taskId
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Get Word Info
 * Retrieve detailed information about a specific vocabulary word.
 *
 * Looks up word metadata including lemma, CEFR level, translations, and usage examples
 * from the vocabulary database.
 *
 * **Authentication Required**: No
 *
 * Args:
 * word (str): The word to look up
 * language (str): Target language code (default: "de")
 * db (AsyncSession): Database session dependency
 *
 * Returns:
 * dict: Word information including:
 * - word: The original word
 * - lemma: Base form of the word
 * - level: CEFR level (A1-C2)
 * - translations: List of translations
 * - examples: Usage examples
 *
 * Raises:
 * HTTPException: 404 if word not found in vocabulary database
 * HTTPException: 500 if database query fails
 *
 * Example:
 * ```bash
 * curl -X GET "http://localhost:8000/api/vocabulary/word-info/Hallo?language=de"
 * ```
 *
 * Response:
 * ```json
 * {
 * "word": "Hallo",
 * "lemma": "hallo",
 * "level": "A1",
 * "translations": ["Hello", "Hi"],
 * "examples": ["Hallo, wie geht es dir?"]
 * }
 * ```
 * @param data The data for the request.
 * @param data.word
 * @param data.language Language code
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getWordInfoApiVocabularyWordInfoWordGet = (data: GetWordInfoApiVocabularyWordInfoWordGetData): CancelablePromise<GetWordInfoApiVocabularyWordInfoWordGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/vocabulary/word-info/{word}',
    path: {
        word: data.word
    },
    query: {
        language: data.language
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Mark Word Known
 * Mark a vocabulary word as known or unknown for the current user.
 *
 * Updates user's vocabulary progress by marking a word as known (mastered)
 * or unknown (needs practice). Supports lookup by lemma, word form, or concept ID.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * request (MarkKnownRequest): Request containing:
 * - concept_id (str, optional): UUID of vocabulary concept
 * - word (str, optional): The word text
 * - lemma (str, optional): Base form of the word
 * - language (str): Language code (default: "de")
 * - known (bool): Whether to mark as known
 * current_user (User): Authenticated user
 * db (AsyncSession): Database session
 *
 * Returns:
 * dict: Update result with:
 * - success: Whether operation succeeded
 * - concept_id: The vocabulary concept ID
 * - known: The new known status
 * - word: The word text
 * - lemma: The word lemma
 * - level: CEFR level
 *
 * Raises:
 * HTTPException: 500 if database update fails
 *
 * Example:
 * ```bash
 * curl -X POST "http://localhost:8000/api/vocabulary/mark-known"           -H "Authorization: Bearer <token>"           -H "Content-Type: application/json"           -d '{
 * "lemma": "hallo",
 * "language": "de",
 * "known": true
 * }'
 * ```
 *
 * Response:
 * ```json
 * {
 * "success": true,
 * "concept_id": "abc-123",
 * "known": true,
 * "word": "Hallo",
 * "lemma": "hallo",
 * "level": "A1"
 * }
 * ```
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const markWordKnownApiVocabularyMarkKnownPost = (data: MarkWordKnownApiVocabularyMarkKnownPostData): CancelablePromise<MarkWordKnownApiVocabularyMarkKnownPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/vocabulary/mark-known',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Mark Word Known By Lemma
 * Mark a word as known or unknown using lemma-based lookup (compatibility endpoint)
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const markWordKnownByLemmaApiVocabularyMarkKnownLemmaPost = (data: MarkWordKnownByLemmaApiVocabularyMarkKnownLemmaPostData): CancelablePromise<MarkWordKnownByLemmaApiVocabularyMarkKnownLemmaPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/vocabulary/mark-known-lemma',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Get Vocabulary Stats
 * Get comprehensive vocabulary learning statistics for the current user.
 *
 * Returns detailed progress metrics including known/unknown word counts by CEFR level,
 * learning streaks, and overall proficiency metrics.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * target_language (str): Target language code (default: "de")
 * translation_language (str): Translation language code (default: "en")
 * current_user (User): Authenticated user
 * db (AsyncSession): Database session
 *
 * Returns:
 * VocabularyStats: Statistics including:
 * - total_words: Total vocabulary size
 * - known_words: Number of mastered words
 * - by_level: Breakdown by CEFR level (A1-C2)
 * - learning_streak: Consecutive days of practice
 * - mastery_percentage: Overall proficiency score
 *
 * Raises:
 * HTTPException: 500 if statistics calculation fails
 *
 * Example:
 * ```bash
 * curl -X GET "http://localhost:8000/api/vocabulary/stats?target_language=de&translation_language=en"           -H "Authorization: Bearer <token>"
 * ```
 *
 * Response:
 * ```json
 * {
 * "total_words": 5000,
 * "known_words": 450,
 * "by_level": {
 * "A1": {"total": 600, "known": 200},
 * "A2": {"total": 800, "known": 150},
 * "B1": {"total": 1000, "known": 100}
 * },
 * "mastery_percentage": 9.0
 * }
 * ```
 * @param data The data for the request.
 * @param data.targetLanguage Target language code
 * @param data.translationLanguage Translation language code
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getVocabularyStatsApiVocabularyStatsGet = (data: GetVocabularyStatsApiVocabularyStatsGetData = {}): CancelablePromise<GetVocabularyStatsApiVocabularyStatsGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/vocabulary/stats',
    query: {
        target_language: data.targetLanguage,
        translation_language: data.translationLanguage
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Get Vocabulary Library
 * Retrieve paginated vocabulary library with optional CEFR level filtering.
 *
 * Returns a paginated list of vocabulary words, optionally filtered by CEFR level,
 * with user-specific progress indicators showing which words are known.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * language (str): Target language code (default: "de")
 * level (str, optional): CEFR level filter (A1, A2, B1, B2, C1, C2)
 * limit (int): Maximum words to return (1-1000, default: 100)
 * offset (int): Pagination offset (default: 0)
 * current_user (User): Authenticated user
 * db (AsyncSession): Database session
 *
 * Returns:
 * dict: Library data with:
 * - words: List of vocabulary entries with known status
 * - total_count: Total matching words
 * - limit: Applied limit
 * - offset: Applied offset
 *
 * Raises:
 * HTTPException: 500 if database query fails
 *
 * Example:
 * ```bash
 * curl -X GET "http://localhost:8000/api/vocabulary/library?level=A1&limit=50"           -H "Authorization: Bearer <token>"
 * ```
 *
 * Response:
 * ```json
 * {
 * "words": [
 * {
 * "lemma": "hallo",
 * "translation": "hello",
 * "level": "A1",
 * "is_known": true
 * }
 * ],
 * "total_count": 600,
 * "limit": 50,
 * "offset": 0
 * }
 * ```
 * @param data The data for the request.
 * @param data.language Language code
 * @param data.level
 * @param data.limit
 * @param data.offset
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getVocabularyLibraryApiVocabularyLibraryGet = (data: GetVocabularyLibraryApiVocabularyLibraryGetData = {}): CancelablePromise<GetVocabularyLibraryApiVocabularyLibraryGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/vocabulary/library',
    query: {
        language: data.language,
        level: data.level,
        limit: data.limit,
        offset: data.offset
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Get Vocabulary Level
 * Get vocabulary for a specific level
 * @param data The data for the request.
 * @param data.level
 * @param data.targetLanguage Target language code
 * @param data.translationLanguage Translation language code
 * @param data.limit
 * @param data.offset
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getVocabularyLevelApiVocabularyLibraryLevelGet = (data: GetVocabularyLevelApiVocabularyLibraryLevelGetData): CancelablePromise<GetVocabularyLevelApiVocabularyLibraryLevelGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/vocabulary/library/{level}',
    path: {
        level: data.level
    },
    query: {
        target_language: data.targetLanguage,
        translation_language: data.translationLanguage,
        limit: data.limit,
        offset: data.offset
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Search Vocabulary
 * Search vocabulary by word or lemma
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const searchVocabularyApiVocabularySearchPost = (data: SearchVocabularyApiVocabularySearchPostData): CancelablePromise<SearchVocabularyApiVocabularySearchPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/vocabulary/search',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Bulk Mark Level
 * Mark all words in a level as known or unknown
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const bulkMarkLevelApiVocabularyLibraryBulkMarkPost = (data: BulkMarkLevelApiVocabularyLibraryBulkMarkPostData): CancelablePromise<BulkMarkLevelApiVocabularyLibraryBulkMarkPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/vocabulary/library/bulk-mark',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Get Supported Languages
 * Get list of supported languages
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getSupportedLanguagesApiVocabularyLanguagesGet = (): CancelablePromise<GetSupportedLanguagesApiVocabularyLanguagesGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/vocabulary/languages'
}); };

/**
 * Get Test Data
 * Get test data for frontend testing
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getTestDataApiVocabularyTestDataGet = (): CancelablePromise<GetTestDataApiVocabularyTestDataGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/vocabulary/test-data'
}); };

/**
 * Get Blocking Words
 * Get blocking words from SRT file
 * @param data The data for the request.
 * @param data.videoPath Video file path
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const getBlockingWordsApiVocabularyBlockingWordsGet = (data: GetBlockingWordsApiVocabularyBlockingWordsGetData): CancelablePromise<GetBlockingWordsApiVocabularyBlockingWordsGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/vocabulary/blocking-words',
    query: {
        video_path: data.videoPath
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Create Vocabulary
 * Create test vocabulary word (primarily for E2E testing).
 *
 * Maps difficulty levels to CEFR levels and creates a global vocabulary word.
 *
 * Args:
 * request: Vocabulary word details
 * current_user: Authenticated user
 * db: Database session
 *
 * Returns:
 * dict: Created vocabulary with id, word, translation, difficulty_level
 *
 * Raises:
 * HTTPException: 400 if creation fails
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const createVocabularyApiVocabularyPost = (data: CreateVocabularyApiVocabularyPostData): CancelablePromise<CreateVocabularyApiVocabularyPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/vocabulary',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Add Custom Word
 * Add a custom user-defined vocabulary word to C2 level.
 *
 * Allows users to add their own vocabulary words that aren't in the system vocabulary.
 * Custom words are always classified as C2 level and are only visible to the user who created them.
 *
 * Args:
 * request: Custom word details
 * current_user: Authenticated user
 * vocabulary_service: Vocabulary service dependency
 *
 * Returns:
 * dict: Created word information including database ID
 *
 * Raises:
 * HTTPException: 400 if word already exists for this user
 * HTTPException: 500 if creation fails
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const addCustomWordApiVocabularyCustomAddPost = (data: AddCustomWordApiVocabularyCustomAddPostData): CancelablePromise<AddCustomWordApiVocabularyCustomAddPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/vocabulary/custom/add',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Delete Custom Word
 * Delete a user-defined custom vocabulary word.
 *
 * Users can only delete their own custom words. System vocabulary cannot be deleted.
 *
 * Args:
 * word_id: Database ID of the custom word
 * current_user: Authenticated user
 * vocabulary_service: Vocabulary service dependency
 *
 * Returns:
 * dict: Success message
 *
 * Raises:
 * HTTPException: 403 if word doesn't belong to user or is system vocabulary
 * HTTPException: 404 if word not found
 * HTTPException: 500 if deletion fails
 * @param data The data for the request.
 * @param data.wordId
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const deleteCustomWordApiVocabularyCustomWordIdDelete = (data: DeleteCustomWordApiVocabularyCustomWordIdDeleteData): CancelablePromise<DeleteCustomWordApiVocabularyCustomWordIdDeleteResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/api/vocabulary/custom/{word_id}',
    path: {
        word_id: data.wordId
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Profile Get
 * Retrieve the current user's complete profile information.
 *
 * Returns user account details, language preferences, and runtime configuration
 * for the user's selected language pair.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * current_user (User): Authenticated user from JWT token
 *
 * Returns:
 * UserProfile: Complete profile with:
 * - id: User UUID
 * - username: User's username
 * - is_admin: Administrator status
 * - created_at: Account creation timestamp
 * - last_login: Last login timestamp
 * - native_language: Native language details (code, name, flag)
 * - target_language: Learning language details (code, name, flag)
 * - language_runtime: Runtime settings for language pair
 *
 * Raises:
 * HTTPException: 500 if profile retrieval fails
 *
 * Example:
 * ```bash
 * curl -X GET "http://localhost:8000/api/profile"           -H "Authorization: Bearer <token>"
 * ```
 *
 * Response:
 * ```json
 * {
 * "id": "user-123",
 * "username": "learner01",
 * "is_admin": false,
 * "created_at": "2024-01-15T10:30:00",
 * "last_login": "2024-10-03T08:15:00",
 * "native_language": {
 * "code": "en",
 * "name": "English",
 * "flag": "ðŸ‡¬ðŸ‡§"
 * },
 * "target_language": {
 * "code": "de",
 * "name": "German",
 * "flag": "ðŸ‡©ðŸ‡ª"
 * },
 * "language_runtime": {
 * "transcription_model": "whisper-large",
 * "translation_model": "opus-en-de"
 * }
 * }
 * ```
 * @returns UserProfile Successful Response
 * @throws ApiError
 */
export const profileGetApiProfileGet = (): CancelablePromise<ProfileGetApiProfileGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/profile'
}); };

/**
 * Profile Get Supported Languages
 * Get list of supported languages
 * @returns string Successful Response
 * @throws ApiError
 */
export const profileGetSupportedLanguagesApiProfileLanguagesGet = (): CancelablePromise<ProfileGetSupportedLanguagesApiProfileLanguagesGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/profile/languages'
}); };

/**
 * Profile Update Languages
 * Update user's native and target language preferences.
 *
 * Changes the user's language learning configuration, updating both the native
 * language and target learning language. This affects subtitle processing,
 * translation models, and vocabulary filtering.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * preferences (LanguagePreferences): Language configuration with:
 * - native_language (str): Native language code (must be supported)
 * - target_language (str): Target learning language code (must be supported)
 * current_user (User): Authenticated user
 *
 * Returns:
 * dict: Update confirmation with:
 * - success: Whether update succeeded
 * - message: Success message
 * - native_language: Updated native language details
 * - target_language: Updated target language details
 * - language_runtime: New runtime configuration
 *
 * Raises:
 * HTTPException: 400 if languages are invalid or identical
 * HTTPException: 500 if update fails
 *
 * Example:
 * ```bash
 * curl -X PUT "http://localhost:8000/api/profile/languages"           -H "Authorization: Bearer <token>"           -H "Content-Type: application/json"           -d '{
 * "native_language": "en",
 * "target_language": "es"
 * }'
 * ```
 *
 * Response:
 * ```json
 * {
 * "success": true,
 * "message": "Language preferences updated successfully",
 * "native_language": {
 * "code": "en",
 * "name": "English",
 * "flag": "ðŸ‡¬ðŸ‡§"
 * },
 * "target_language": {
 * "code": "es",
 * "name": "Spanish",
 * "flag": "ðŸ‡ªðŸ‡¸"
 * },
 * "language_runtime": {
 * "transcription_model": "whisper-large",
 * "translation_model": "opus-en-es"
 * }
 * }
 * ```
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const profileUpdateLanguagesApiProfileLanguagesPut = (data: ProfileUpdateLanguagesApiProfileLanguagesPutData): CancelablePromise<ProfileUpdateLanguagesApiProfileLanguagesPutResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/api/profile/languages',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Profile Get Settings
 * Get user settings
 * @returns UserSettings Successful Response
 * @throws ApiError
 */
export const profileGetSettingsApiProfileSettingsGet = (): CancelablePromise<ProfileGetSettingsApiProfileSettingsGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/profile/settings'
}); };

/**
 * Profile Update Settings
 * Update user settings
 * @param data The data for the request.
 * @param data.requestBody
 * @returns UserSettings Successful Response
 * @throws ApiError
 */
export const profileUpdateSettingsApiProfileSettingsPut = (data: ProfileUpdateSettingsApiProfileSettingsPutData): CancelablePromise<ProfileUpdateSettingsApiProfileSettingsPutResponse> => { return __request(OpenAPI, {
    method: 'PUT',
    url: '/api/profile/settings',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Progress Get User
 * Retrieve comprehensive learning progress for the current user.
 *
 * Returns cumulative learning statistics including videos watched, vocabulary learned,
 * learning streaks, experience points, and achievement tracking.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * current_user (User): Authenticated user
 *
 * Returns:
 * UserProgress: Progress metrics with:
 * - user_id: User identifier
 * - total_videos_watched: Total videos completed
 * - total_watch_time: Total watching time in minutes
 * - vocabulary_learned: Number of words mastered
 * - current_streak: Consecutive days of activity
 * - longest_streak: Best streak achieved
 * - level: Current proficiency level
 * - experience_points: Total XP earned
 * - daily_goals_completed: Goals completed today
 * - weekly_goals_completed: Goals completed this week
 * - last_activity: Timestamp of last activity
 * - achievements: List of earned achievements
 * - learning_stats: Additional statistics
 *
 * Raises:
 * HTTPException: 500 if progress retrieval fails
 *
 * Example:
 * ```bash
 * curl -X GET "http://localhost:8000/api/progress/user"           -H "Authorization: Bearer <token>"
 * ```
 *
 * Response:
 * ```json
 * {
 * "user_id": "user-123",
 * "total_videos_watched": 15,
 * "total_watch_time": 450.5,
 * "vocabulary_learned": 234,
 * "current_streak": 7,
 * "longest_streak": 14,
 * "level": "Intermediate",
 * "experience_points": 1250,
 * "daily_goals_completed": 3,
 * "weekly_goals_completed": 15,
 * "last_activity": "2024-10-03T10:30:00",
 * "achievements": ["first_video", "streak_7", "vocab_100"],
 * "learning_stats": {
 * "average_session_duration": 30.0,
 * "favorite_series": "Learn German"
 * }
 * }
 * ```
 * @returns UserProgress Successful Response
 * @throws ApiError
 */
export const progressGetUserApiProgressUserGet = (): CancelablePromise<ProgressGetUserApiProgressUserGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/progress/user'
}); };

/**
 * Progress Update User
 * Update user progress data
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const progressUpdateUserApiProgressUpdatePost = (data: ProgressUpdateUserApiProgressUpdatePostData): CancelablePromise<ProgressUpdateUserApiProgressUpdatePostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/progress/update',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Progress Get Daily
 * Get daily progress for the last N days
 * @param data The data for the request.
 * @param data.days
 * @returns DailyProgress Successful Response
 * @throws ApiError
 */
export const progressGetDailyApiProgressDailyGet = (data: ProgressGetDailyApiProgressDailyGetData = {}): CancelablePromise<ProgressGetDailyApiProgressDailyGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/progress/daily',
    query: {
        days: data.days
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Game Start Session
 * Start a new vocabulary game session for the current user.
 *
 * Creates a new game session with generated questions based on game type and difficulty.
 * Supports vocabulary translation, listening comprehension, and general comprehension games.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * game_request (StartGameRequest): Game configuration with:
 * - game_type (GameType): "vocabulary", "listening", or "comprehension"
 * - difficulty (GameDifficulty): "beginner", "intermediate", or "advanced"
 * - video_id (str, optional): Associated video for context
 * - total_questions (int): Number of questions (1-50, default: 10)
 * current_user (User): Authenticated user
 * game_service (GameSessionService): Game session service
 *
 * Returns:
 * GameSession: Created game session with:
 * - session_id: Unique session identifier
 * - game_type: Type of game
 * - difficulty: Difficulty level
 * - total_questions: Number of questions
 * - status: "active"
 * - session_data: Generated questions
 *
 * Raises:
 * HTTPException: 500 if session creation fails
 *
 * Example:
 * ```bash
 * curl -X POST "http://localhost:8000/api/game/start"           -H "Authorization: Bearer <token>"           -H "Content-Type: application/json"           -d '{
 * "game_type": "vocabulary",
 * "difficulty": "intermediate",
 * "total_questions": 15
 * }'
 * ```
 *
 * Response:
 * ```json
 * {
 * "session_id": "abc-123-def",
 * "user_id": "user-456",
 * "game_type": "vocabulary",
 * "difficulty": "intermediate",
 * "status": "active",
 * "total_questions": 15,
 * "current_question": 0,
 * "score": 0,
 * "max_score": 150
 * }
 * ```
 * @param data The data for the request.
 * @param data.requestBody
 * @returns GameSession Successful Response
 * @throws ApiError
 */
export const gameStartSessionApiGameStartPost = (data: GameStartSessionApiGameStartPostData): CancelablePromise<GameStartSessionApiGameStartPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/game/start',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Game Get Session
 * Get a specific game session
 *
 * Args:
 * session_id: Game session identifier
 * current_user: Authenticated user
 * game_service: Game session service
 *
 * Returns:
 * GameSession if found
 *
 * Raises:
 * HTTPException: 404 if session not found
 * HTTPException: 500 if retrieval fails
 * @param data The data for the request.
 * @param data.sessionId
 * @returns GameSession Successful Response
 * @throws ApiError
 */
export const gameGetSessionApiGameSessionSessionIdGet = (data: GameGetSessionApiGameSessionSessionIdGetData): CancelablePromise<GameGetSessionApiGameSessionSessionIdGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/game/session/{session_id}',
    path: {
        session_id: data.sessionId
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Game Submit Answer
 * Submit an answer for a game question and receive immediate feedback.
 *
 * Evaluates the user's answer against the correct answer, updates score, and
 * automatically completes the session when all questions are answered.
 *
 * **Authentication Required**: Yes
 *
 * Args:
 * answer_request (AnswerRequest): Answer submission with:
 * - session_id (str): Game session identifier
 * - question_id (str): Question identifier
 * - user_answer (str): User's submitted answer
 * - correct_answer (str, optional): Expected correct answer
 * - points (int): Points available for this question
 * current_user (User): Authenticated user
 * game_service (GameSessionService): Game session service
 *
 * Returns:
 * dict: Answer result with:
 * - is_correct: Whether answer was correct
 * - points_earned: Points awarded
 * - current_score: Updated total score
 * - questions_remaining: Remaining questions
 * - session_completed: Whether session is finished
 *
 * Raises:
 * HTTPException: 404 if session or question not found
 * HTTPException: 400 if question already answered or session not active
 * HTTPException: 500 if answer processing fails
 *
 * Example:
 * ```bash
 * curl -X POST "http://localhost:8000/api/game/answer"           -H "Authorization: Bearer <token>"           -H "Content-Type: application/json"           -d '{
 * "session_id": "abc-123",
 * "question_id": "q1",
 * "user_answer": "hola",
 * "points": 10
 * }'
 * ```
 *
 * Response:
 * ```json
 * {
 * "is_correct": true,
 * "points_earned": 10,
 * "current_score": 10,
 * "questions_remaining": 9,
 * "session_completed": false
 * }
 * ```
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const gameSubmitAnswerApiGameAnswerPost = (data: GameSubmitAnswerApiGameAnswerPostData): CancelablePromise<GameSubmitAnswerApiGameAnswerPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/game/answer',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Game Get User Sessions
 * Get user's game sessions
 *
 * Args:
 * limit: Maximum number of sessions to return
 * current_user: Authenticated user
 * game_service: Game session service
 *
 * Returns:
 * List of GameSession objects
 *
 * Raises:
 * HTTPException: 500 if retrieval fails
 * @param data The data for the request.
 * @param data.limit
 * @returns GameSession Successful Response
 * @throws ApiError
 */
export const gameGetUserSessionsApiGameSessionsGet = (data: GameGetUserSessionsApiGameSessionsGetData = {}): CancelablePromise<GameGetUserSessionsApiGameSessionsGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/game/sessions',
    query: {
        limit: data.limit
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Parse Srt Content
 * Parse SRT subtitle content and return structured segment data.
 *
 * Converts raw SRT text format into structured JSON with parsed timestamps,
 * segment indices, and text content. This endpoint centralizes SRT parsing
 * logic on the backend, ensuring consistent parsing across the application.
 *
 * **Authentication Required**: No
 *
 * Args:
 * request (ParseSRTRequest): Request with:
 * - content (str): Raw SRT file content
 *
 * Returns:
 * ParseSRTResponse: Parsed data with:
 * - segments: List of subtitle segments
 * - index: Segment number
 * - start_time: Start timestamp in seconds
 * - end_time: End timestamp in seconds
 * - text: Subtitle text
 * - original_text: Original text (if available)
 * - translation: Translation text (if available)
 * - total_segments: Total number of segments
 * - duration: Total video duration in seconds
 *
 * Raises:
 * HTTPException: 400 if SRT content is malformed or unparseable
 *
 * Example:
 * ```bash
 * curl -X POST "http://localhost:8000/api/srt/parse"           -H "Content-Type: application/json"           -d '{
 * "content": "1\n00:00:00,000 --> 00:00:05,000\nHallo!\n\n2\n00:00:05,500 --> 00:00:10,000\nWie geht es dir?"
 * }'
 * ```
 *
 * Response:
 * ```json
 * {
 * "segments": [
 * {
 * "index": 1,
 * "start_time": 0.0,
 * "end_time": 5.0,
 * "text": "Hallo!",
 * "original_text": "",
 * "translation": ""
 * },
 * {
 * "index": 2,
 * "start_time": 5.5,
 * "end_time": 10.0,
 * "text": "Wie geht es dir?",
 * "original_text": "",
 * "translation": ""
 * }
 * ],
 * "total_segments": 2,
 * "duration": 10.0
 * }
 * ```
 *
 * Note:
 * This endpoint should be used by frontend instead of client-side SRT parsing
 * to ensure consistency and reduce code duplication.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns ParseSRTResponse Successful Response
 * @throws ApiError
 */
export const parseSrtContentApiSrtParsePost = (data: ParseSrtContentApiSrtParsePostData): CancelablePromise<ParseSrtContentApiSrtParsePostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/srt/parse',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Parse Srt File
 * Parse an uploaded SRT file and return structured data.
 *
 * Args:
 * file: Uploaded SRT file
 *
 * Returns:
 * Parsed SRT segments with metadata
 *
 * Raises:
 * HTTPException: If file processing fails
 * @param data The data for the request.
 * @param data.formData
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const parseSrtFileApiSrtParseFilePost = (data: ParseSrtFileApiSrtParseFilePostData): CancelablePromise<ParseSrtFileApiSrtParseFilePostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/srt/parse-file',
    formData: data.formData,
    mediaType: 'multipart/form-data',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Convert To Srt
 * Convert structured segment data back to SRT format.
 *
 * Args:
 * request: Segments to convert
 *
 * Returns:
 * SRT formatted content
 *
 * Raises:
 * HTTPException: If conversion fails
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const convertToSrtApiSrtConvertToSrtPost = (data: ConvertToSrtApiSrtConvertToSrtPostData): CancelablePromise<ConvertToSrtApiSrtConvertToSrtPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/srt/convert-to-srt',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Validate Srt Content
 * Validate SRT content without full parsing.
 *
 * Args:
 * content: SRT content to validate
 *
 * Returns:
 * Validation result with issues found
 * @param data The data for the request.
 * @param data.content
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const validateSrtContentApiSrtValidateGet = (data: ValidateSrtContentApiSrtValidateGetData): CancelablePromise<ValidateSrtContentApiSrtValidateGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/srt/validate',
    query: {
        content: data.content
    },
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Log Frontend Entry
 * Receive and process log entries from the frontend application.
 *
 * Accepts either a single log entry or a batch of log entries from the frontend,
 * routing them to the backend logging system for centralized debugging and monitoring.
 * Supports standard log levels and includes contextual metadata.
 *
 * **Authentication Required**: No
 *
 * Args:
 * payload (FrontendLogEntry | FrontendLogBatch): Log entry or batch with:
 * - timestamp: ISO 8601 timestamp
 * - level: Log level ("debug", "info", "warn", "error")
 * - category: Log category (e.g., "api", "render", "user-action")
 * - message: Log message
 * - data (optional): Structured log data
 * - error (optional): Error message if applicable
 * - stack (optional): Stack trace for errors
 * - url (optional): Current page URL
 * - userAgent (optional): Browser user agent
 * - userId (optional): User identifier
 *
 * Returns:
 * dict: Acknowledgment with:
 * - success: Always true
 * - status: "logged"
 * - count: Number of log entries processed (for batches)
 * - timestamp: Timestamp of first log entry
 *
 * Example (single entry):
 * ```bash
 * curl -X POST "http://localhost:8000/api/debug/frontend-logs"           -H "Content-Type: application/json"           -d '{
 * "timestamp": "2024-10-03T10:30:00.000Z",
 * "level": "error",
 * "category": "api",
 * "message": "Failed to fetch vocabulary",
 * "error": "Network request failed",
 * "userId": "user-123"
 * }'
 * ```
 *
 * Example (batch):
 * ```bash
 * curl -X POST "http://localhost:8000/api/debug/frontend-logs"           -H "Content-Type: application/json"           -d '{
 * "logs": [
 * {
 * "timestamp": "2024-10-03T10:30:00.000Z",
 * "level": "info",
 * "category": "navigation",
 * "message": "User navigated to vocabulary page"
 * },
 * {
 * "timestamp": "2024-10-03T10:30:05.000Z",
 * "level": "debug",
 * "category": "api",
 * "message": "Fetching vocabulary library",
 * "data": {"limit": 100, "offset": 0}
 * }
 * ]
 * }'
 * ```
 *
 * Note:
 * Log entries are written to the backend's "frontend" logger and can be
 * monitored alongside backend logs for comprehensive debugging.
 * @param data The data for the request.
 * @param data.requestBody
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const logFrontendEntryApiDebugFrontendLogsPost = (data: LogFrontendEntryApiDebugFrontendLogsPostData): CancelablePromise<LogFrontendEntryApiDebugFrontendLogsPostResponse> => { return __request(OpenAPI, {
    method: 'POST',
    url: '/api/debug/frontend-logs',
    body: data.requestBody,
    mediaType: 'application/json',
    errors: {
        422: 'Validation Error'
    }
}); };

/**
 * Debug Health
 * Debug health check endpoint
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const debugHealthApiDebugHealthGet = (): CancelablePromise<DebugHealthApiDebugHealthGetResponse> => { return __request(OpenAPI, {
    method: 'GET',
    url: '/api/debug/health'
}); };

/**
 * Cleanup Test Data
 * Clean up test data created by e2e tests
 *
 * Deletes all users and related data that match e2e test patterns:
 * - Users with emails matching e2e.*@langplug.com
 * - Users with usernames starting with e2euser_
 *
 * **Authentication Required**: No (only available in debug mode)
 *
 * Returns:
 * dict: Cleanup summary with counts of deleted records
 * @returns unknown Successful Response
 * @throws ApiError
 */
export const cleanupTestDataApiTestCleanupDelete = (): CancelablePromise<CleanupTestDataApiTestCleanupDeleteResponse> => { return __request(OpenAPI, {
    method: 'DELETE',
    url: '/api/test/cleanup'
}); };